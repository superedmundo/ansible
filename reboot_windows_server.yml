---
- name: Reboot Windows Server if Necesary
  hosts: 10.100.1.116
  gather_facts: no 
  vars_files:
    - "./oscarc_otobo_password"
  collections:
    - ditra.cisco

  vars:

    ipServer: null
    forceReboot: false
    sinceDays: -7
    eventId: 22

    # reboot_timeout 
    # Maximum seconds to wait for machine to re-appear on the network and respond to a test command.
    # This timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value.
    # Default: 600.0
    rebootTimeout: 600

    # post_reboot_delay  
    # Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.
    # This is useful if you want wait for something to settle despite your connection already working.
    # Default: 0.0
    postReboot_delay: 0

    # NOTIFICACIONES
    # Sms 
    notification_sms: null

    # Email
    notification_email: null

    # Variables internas de control de flujo
    something_wrong: false
    result_process: null

    # vars for otobo changes
    validate_certs: false
    otobo_user: baltadlakd
    base_url: https://10.100.1.124/otobo/nph-genericinterface.pl/Webservice
    module:
      login: /care
      cmdb: /CMDB/ConfigItem
    path:
      login: "{{ base_url }}{{ module.login }}/login"
      Ticket: "{{ base_url }}{{ module.login }}/Ticket"
    TicketID: null

  tasks:

  # tasks to update status in oboto
    - name: Otobo login, get session id
      delegate_to: localhost
      ansible.builtin.uri:
        url: "{{ path.login }}"
        method: POST
        body_format: json
        body:
          UserLogin: "{{ otobo_user }}"
          Password: "{{ otobo_password }}"
        validate_certs: "{{ validate_certs }}"
        return_content: true
      register: response

    - name: Get SessionID from login response
      ansible.builtin.set_fact:
        session_id: "{{ r.SessionID }}"
      vars:
        r: "{{ response.content | from_json }}"
      delegate_to: localhost
    
    - name: Set auto process ticket as processing status
      delegate_to: localhost
      ansible.builtin.uri:
        url: "{{ path.Ticket }}/{{ TicketID }}/Update"
        method: POST
        body_format: json
        body:
          SessionID: "{{ session_id }}"
          TicketID: "{{ TicketID }}"
          DynamicField:
           - Name: AutoStatus
             Value: processing

        validate_certs: "{{ validate_certs }}"
        return_content: true
      register: response
      failed_when: "response.status != 200"
      run_once: true
      when: TicketID is not none and session_id is defined

    - name: Desplegando las variables que llegaron.
      ansible.builtin.debug:
        msg: 
          ipServer: "{{ ipServer }}" 
          forceReboot: "{{ forceReboot }}" 
          sinceDays: "{{ sinceDays }}" 
          eventId: "{{ eventId }}" 
          rebootTimeout: "{{ rebootTimeout }}" 
          postReboot_delay: "{{ postReboot_delay }}" 

          # NOTIFICACIONES
          # Email
          notification_email: "{{ notification_email }}"

  # Conexión

    - name: Blocke
      when: 
        - ipServer is defined 
        - sinceDays is defined 
        - eventId is defined
      block:
        - name: Check existing Event
          ansible.windows.win_powershell:
            script: |
              Get-WinEvent -FilterHashtable @{logname='System';id={{eventId}};StartTime=(get-date).AddDays({{sinceDays}});}
          register: result_check

        # |ft TimeCreated,Id,Message
        # - name: Establecer el valor de algo Erroneo si ya esta dada de alta
        #   when: result_check.output[0].Alias is defined 
        #   ansible.builtin.set_fact:
        #     something_wrong: true

        # - name: Crear mensaje notificación fallida
        #   when: something_wrong == true
        #   ansible.builtin.set_fact:
        #     result_create: "Ya existe el buzón dado de alta"

        - name: result_check
          ansible.builtin.debug:
            msg: 
              result_check: "{{ result_check }}" 

        - name: Reboot the machine with all defaults
          ansible.windows.win_reboot:
            reboot_timeout: "{{rebootTimeout}}"
            post_reboot_delay: "{{postReboot_delay}}"
          register: result_reboot

        - name: result_reboot
          ansible.builtin.debug:
            msg: 
              result_reboot: "{{ result_reboot }}" 

        # Or you can make win_reboot validate exactly what you need to work before running the next task
        - name: Validate that the netlogon service has started, before running the next task
          ansible.windows.win_reboot:
          test_command: 'exit (Get-Service -Name Netlogon).Status -ne "Running"'

        - name: Validated!
          ansible.builtin.debug:
            msg: 
              result_reboot: "{{ result_reboot }}" 

      rescue:         

        - name: Establecer el valor de algo Erroneo
          ansible.builtin.set_fact:
            something_wrong: true

        # - name: Crear mensaje notificación fallida
        #   when: something_wrong == true
        #   ansible.builtin.set_fact:
        #     result_process: "Ocurrió un error al tratar de crear el buzón"    

  # NOTIFICACIONES
  # Crear mensaje para Notificación
    - name: Crear mensaje notificación exitosa
      when: something_wrong == false
      ansible.builtin.set_fact:
        result_process: "Se reinició el server: {{ ipServer }}"

    - name: Crear mensaje notificación fallida
      when: something_wrong == true and result_process is not defined
      ansible.builtin.set_fact:
        result_process: "Ocurrió un error"

    - name: Send notification_email
      when: notification_email is defined and something_wrong == false
      ansible.builtin.include_role:
        name: ditra.cisco.send_email
        apply:
          delegate_to: localhost
      vars:
        subject: El reinicio del server fue exitoso
        body: |
          Todo bien
          {{result_process}}

        to_email: "{{ notification_email }}"
        alert: true
        
    - name: Send notification_email_on_fail
      when: 
        - notification_email is defined 
        - something_wrong == true 
        - result_process is defined
      ansible.builtin.include_role:
        name: ditra.cisco.send_email
        apply:
          delegate_to: localhost
      vars:
        subject: Ocurrió un error al tratar de reiniciar el servidor
        body: |
          Algo salió mal, revisa la bitácora {{result_process}}

        to_email: "{{ notification_email }}"
        alert: true
        
  # Actualización del Ticket de Otobo
    - name: Post report to ticket on otobo
      delegate_to: localhost
      ansible.builtin.uri:
        url: "{{ path.Ticket }}/{{ TicketID }}/Update"
        method: POST
        body_format: json
        body:
          SessionID: "{{ session_id }}"
          TicketID: "{{ TicketID }}"
          Article:
            CommunicationChannel: Internal
            IsVisibleForCustomer: 1
            Subject: Reporte ansible
            Body: "{{ result_process }}"
            ContentType: text/plain; charset=utf-8
          DynamicField:
           - Name: AutoStatus
             Value: completed
        validate_certs: "{{ validate_certs }}"
        return_content: true
      register: response
      failed_when: "response.status != 200"
      run_once: true
      when: TicketID is not none and session_id is defined