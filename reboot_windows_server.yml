---
- name: Reboot Windows Server if Necesary
  hosts: "{{ target_host | default('all') }} "
  gather_facts: no 
  vars_files:
    - "./oscarc_otobo_password"
  collections:
    - ditra.cisco

  vars:

    target_host: null
    forceReboot: false
    sinceDays: -7
    eventId: 22

    # reboot_timeout 
    # Maximum seconds to wait for machine to re-appear on the network and respond to a test command.
    # This timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value.
    # Default: 600.0
    rebootTimeout: 600

    # post_reboot_delay  
    # Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.
    # This is useful if you want wait for something to settle despite your connection already working.
    # Default: 0.0
    postReboot_delay: 0

    # NOTIFICACIONES
    # Sms 
    notification_sms: null

    # Email
    notification_email: null

    # Variables internas de control de flujo
    something_wrong: false
    result_process: null
    events: null

    # vars for otobo changes
    validate_certs: false
    otobo_user: baltadlakd
    base_url: https://10.100.1.124/otobo/nph-genericinterface.pl/Webservice
    module:
      login: /care
      cmdb: /CMDB/ConfigItem
    path:
      login: "{{ base_url }}{{ module.login }}/login"
      Ticket: "{{ base_url }}{{ module.login }}/Ticket"
    TicketID: null

  tasks:

  # tasks to update status in oboto
    - name: Otobo login, get session id
      when: inventory_hostname == target_host
      delegate_to: localhost
      ansible.builtin.uri:
        url: "{{ path.login }}"
        method: POST
        body_format: json
        body:
          UserLogin: "{{ otobo_user }}"
          Password: "{{ otobo_password }}"
        validate_certs: "{{ validate_certs }}"
        return_content: true
      register: response

    - name: Get SessionID from login response
      when: inventory_hostname == target_host
      ansible.builtin.set_fact:
        session_id: "{{ r.SessionID }}"
      vars:
        r: "{{ response.content | from_json }}"
      delegate_to: localhost
    
    - name: Set auto process ticket as processing status
      delegate_to: localhost
      ansible.builtin.uri:
        url: "{{ path.Ticket }}/{{ TicketID }}/Update"
        method: POST
        body_format: json
        body:
          SessionID: "{{ session_id }}"
          TicketID: "{{ TicketID }}"
          DynamicField:
           - Name: AutoStatus
             Value: processing

        validate_certs: "{{ validate_certs }}"
        return_content: true
      register: response
      failed_when: "response.status != 200"
      run_once: true
      when: TicketID is not none and session_id is defined and inventory_hostname == target_host

    - name: Desplegando las variables que llegaron.
      ansible.builtin.debug:
        msg: 
          target_host: "{{ target_host }}" 
          forceReboot: "{{ forceReboot }}" 
          sinceDays: "{{ sinceDays }}" 
          eventId: "{{ eventId }}" 
          rebootTimeout: "{{ rebootTimeout }}" 
          postReboot_delay: "{{ postReboot_delay }}" 
          inventory_hostname: "{{ inventory_hostname }}"
          TicketID: "{{ TicketID }}"

          # NOTIFICACIONES
          # Email
          notification_email: "{{ notification_email }}"

  # Conexión

    - name: Blocke
      when: 
        - target_host is defined 
        - sinceDays is defined 
        - eventId is defined
        - inventory_hostname == target_host
      block:
        - name: Check existing Event
          ansible.windows.win_powershell:
            script: |
              Get-WinEvent -FilterHashtable @{logname='System';id={{eventId}};StartTime=(get-date).AddDays({{sinceDays}});}
          register: result_check

        - name: result_check
          ansible.builtin.debug:
            msg: 
              result_check: "{{ result_check }}" 
    
        - name: set_fact Events
          when: result_check.output | length > 0
          delegate_to: localhost
          ansible.builtin.set_fact:
            #events: "{{ result_check.output |  to_json(indent=2) }}"
            events: "{{ result_check | community.general.json_query('output[*].Message') | replace('Restart Required: To complete the installation of the following updates, the computer will be restarted within 15 minutes: \\n- ','')  }}"

        - name: BloqueReboot
          when: result_check.output | length > 0
          block:
          - name: Reboot the machine
            ansible.windows.win_reboot:
              reboot_timeout: "{{rebootTimeout}}"
              post_reboot_delay: "{{postReboot_delay}}"
              #test_command: 'exit (Get-Service -Name Netlogon).Status -ne "Running"'
              test_command: 'exit (Get-Service -Name Server).Status -ne "Running"'
            register: result_reboot

          - name: result_reboot
            ansible.builtin.debug:
              msg: 
                result_reboot: "{{ result_reboot }}" 

        - name: BloqueReboot
          when: result_check.error | length > 0
          ansible.builtin.set_fact:
            result_process: "El server: {{ target_host }} no tiene actualizaciones críticas. No es necesario reiniciar."

      rescue:         

        - name: Establecer el valor de algo Erroneo
          ansible.builtin.set_fact:
            something_wrong: true

        # - name: Crear mensaje notificación fallida
        #   when: something_wrong == true
        #   ansible.builtin.set_fact:
        #     result_process: "Ocurrió un error al tratar de crear el buzón"    

  # NOTIFICACIONES
  # Crear mensaje para Notificación

    - name: Crear mensaje notificación exitosa
      when: 
        - something_wrong == false 
        - result_check.error | length == 0
      ansible.builtin.set_fact:
        result_process: "Se reinició el server: {{ target_host }} y el servicio Server esta Running; {{ events | to_json(indent=2) }}"

    - name: Crear mensaje notificación fallida
      when: something_wrong == true 
      ansible.builtin.set_fact:
        result_process: "Ocurrió un error"

    - name: Send notification_email
      when: notification_email is defined and something_wrong == false and inventory_hostname == target_host
      ansible.builtin.include_role:
        name: ditra.cisco.send_email
        apply:
          delegate_to: localhost
      vars:
        subject: El proceso de reinicio de server fue exitoso
        body: |
          Todo bien
          {{result_process}}

        to_email: "{{ notification_email }}"
        alert: true
        
    - name: Send notification_email_on_fail
      when: 
        - notification_email is defined 
        - something_wrong == true 
      ansible.builtin.include_role:
        name: ditra.cisco.send_email
        apply:
          delegate_to: localhost
      vars:
        subject: Ocurrió un error en el proceso de reiniciar el servidor
        body: |
          Algo salió mal, revisa la bitácora {{result_process}}

        to_email: "{{ notification_email }}"
        alert: true
        
  # Actualización del Ticket de Otobo
    - name: Post report to ticket on otobo
      delegate_to: localhost
      ansible.builtin.uri:
        url: "{{ path.Ticket }}/{{ TicketID }}/Update"
        method: POST
        body_format: json
        body:
          SessionID: "{{ session_id }}"
          TicketID: "{{ TicketID }}"
          Article:
            CommunicationChannel: Internal
            IsVisibleForCustomer: 1
            Subject: Reporte ansible
            Body: "{{ result_process }}"
            ContentType: text/plain; charset=utf-8
          DynamicField:
           - Name: AutoStatus
             Value: completed
        validate_certs: "{{ validate_certs }}"
        return_content: true
      register: response
      failed_when: "response.status != 200"
      run_once: true
      when: TicketID is not none and session_id is defined and inventory_hostname == target_host